<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Grid Pathfinding (A*, Dijkstra, Greedy, Weighted A*, BFS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Grid Pathfinding (A*, Dijkstra, Greedy, Weighted A*, BFS)</h1>

  <div class="toolbar" role="group" aria-label="Controls">
    <fieldset class="group" style="border:0; margin:0; padding:0;">
      <legend>Tool:</legend>
      <label><input type="radio" name="tool" value="wall" checked> Draw walls</label>
      <label><input type="radio" name="tool" value="erase"> Erase</label>
      <label><input type="radio" name="tool" value="start"> Set Start</label>
      <label><input type="radio" name="tool" value="goal"> Set Goal</label>
    </fieldset>

    <div class="group" title="Fill the grid with random walls by density">
      <label>Random walls:
        <input id="density" type="range" min="0" max="0.6" step="0.02" value="0.28">
        <span id="densityVal">0.28</span>
      </label>
      <button id="randomizeBtn">Randomize</button>
      <button id="clearWallsBtn">Clear walls</button>
    </div>

    <div class="spacer"></div>

    <div class="group">
      <label>Algorithm:
        <select id="algo">
          <option value="astar">A*</option>
          <option value="wastar">Weighted A*</option>
          <option value="dijkstra">Dijkstra</option>
          <option value="greedy">Greedy Best-First</option>
          <option value="bfs">BFS (unit weights)</option>
          <option value="dstar">D* Lite</option>
          <option value="lpa">LPA*</option>
        </select>
      </label>
      <label id="wWrap" class="group">
        w=
        <input id="weight" type="range" min="1" max="5" step="0.1" value="1.5">
        <span id="weightVal">1.5</span>
      </label>
      <label title="Allow diagonal movement">
        <input type="checkbox" id="diag"> Diagonals
      </label>
      <button id="stepBtn">Step</button>
      <button id="autoBtn">Run/Auto-play</button>
      <button id="pauseBtn">Pause</button>
      <button id="resumeBtn">Resume</button>
      <label title="Speed">
        Speed:
        <input id="speedSlider" type="range" min="50" max="1000" step="10" value="300">
        <span id="speedVal">300ms</span>
      </label>
      <button id="runBtn">Run</button>
      <button id="clearPathBtn">Clear path</button>
    // D* Lite implementation
    function dstarLite(start, goal, allowDiag) {
      // Minimal D* Lite for grid, single-shot (no incremental replanning)
      // Reference: Koenig & Likhachev (2002)
      lastOpen = createBoolGrid(false);
      lastClosed = createBoolGrid(false);
      lastPath = [];
      // Key: [g, rhs]
      const g = Array.from({ length: rows }, () => Array(cols).fill(Infinity));
      const rhs = Array.from({ length: rows }, () => Array(cols).fill(Infinity));
      const cameFrom = Array.from({ length: rows }, () => Array(cols).fill(null));
      const open = [];
      const inOpen = createBoolGrid(false);
      const inClosed = createBoolGrid(false);
      const { x: sx, y: sy } = start;
      const { x: gx, y: gy } = goal;
      if (!isWalkable(sx, sy) || !isWalkable(gx, gy)) return { found: false, steps: 0 };
      rhs[gy][gx] = 0;
      open.push({ x: gx, y: gy, k: [heuristic(sx, sy, gx, gy, allowDiag), 0] });
      inOpen[gy][gx] = true;
      let steps = 0;
      function key(x, y) {
        return [Math.min(g[y][x], rhs[y][x]) + heuristic(sx, sy, x, y, allowDiag), Math.min(g[y][x], rhs[y][x])];
      }
      function updateVertex(x, y) {
        if (!(x === gx && y === gy)) {
          let minRhs = Infinity;
          let minFrom = null;
          for (const nb of getNeighborsWeighted(x, y, allowDiag)) {
            const nx = nb.x, ny = nb.y, cost = nb.cost;
            if (g[ny][nx] + cost < minRhs) {
              minRhs = g[ny][nx] + cost;
              minFrom = { x: nx, y: ny };
            }
          }
          rhs[y][x] = minRhs;
          cameFrom[y][x] = minFrom;
        }
        if (inOpen[y][x]) {
          for (let i = 0; i < open.length; i++) {
            if (open[i].x === x && open[i].y === y) {
              open.splice(i, 1);
              break;
            }
          }
          inOpen[y][x] = false;
        }
        if (g[y][x] !== rhs[y][x]) {
          open.push({ x, y, k: key(x, y) });
          inOpen[y][x] = true;
        }
      }
      function popMin() {
        let minIdx = 0;
        let minK = open[0].k;
        for (let i = 1; i < open.length; i++) {
          const k = open[i].k;
          if (k[0] < minK[0] || (k[0] === minK[0] && k[1] < minK[1])) {
            minK = k;
            minIdx = i;
          }
        }
        const node = open[minIdx];
        open.splice(minIdx, 1);
        inOpen[node.y][node.x] = false;
        return node;
      }
      updateVertex(sx, sy);
      while (open.length > 0 && (g[sy][sx] !== rhs[sy][sx] || open[0].k[0] < key(sx, sy)[0] || open[0].k[1] < key(sx, sy)[1])) {
        steps++;
        const u = popMin();
        lastClosed[u.y][u.x] = true;
        if (g[u.y][u.x] > rhs[u.y][u.x]) {
          g[u.y][u.x] = rhs[u.y][u.x];
          for (const nb of getNeighborsWeighted(u.x, u.y, allowDiag)) {
            updateVertex(nb.x, nb.y);
          }
        } else {
          g[u.y][u.x] = Infinity;
          updateVertex(u.x, u.y);
          for (const nb of getNeighborsWeighted(u.x, u.y, allowDiag)) {
            updateVertex(nb.x, nb.y);
          }
        }
      }
      // Reconstruct path from start
      let path = [];
      let cur = { x: sx, y: sy };
      while (cur && !(cur.x === gx && cur.y === gy)) {
        path.push(cur);
        cur = cameFrom[cur.y][cur.x];
      }
      if (cur) path.push(cur);
      lastPath = path;
      lastOpen = inOpen.map(r => r.slice());
      lastClosed = inClosed.map(r => r.slice());
      return { found: g[sy][sx] < Infinity, path, steps, cost: g[sy][sx] };
    }

    // LPA* implementation
    function lpaStar(start, goal, allowDiag) {
      // Minimal LPA* for grid, single-shot (no incremental replanning)
      // Reference: Koenig, Likhachev, Furcy (2004)
      lastOpen = createBoolGrid(false);
      lastClosed = createBoolGrid(false);
      lastPath = [];
      const g = Array.from({ length: rows }, () => Array(cols).fill(Infinity));
      const rhs = Array.from({ length: rows }, () => Array(cols).fill(Infinity));
      const cameFrom = Array.from({ length: rows }, () => Array(cols).fill(null));
      const open = [];
      const inOpen = createBoolGrid(false);
      const inClosed = createBoolGrid(false);
      const { x: sx, y: sy } = start;
      const { x: gx, y: gy } = goal;
      if (!isWalkable(sx, sy) || !isWalkable(gx, gy)) return { found: false, steps: 0 };
      rhs[sy][sx] = 0;
      open.push({ x: sx, y: sy, k: [heuristic(sx, sy, gx, gy, allowDiag), 0] });
      inOpen[sy][sx] = true;
      let steps = 0;
      function key(x, y) {
        return [Math.min(g[y][x], rhs[y][x]) + heuristic(x, y, gx, gy, allowDiag), Math.min(g[y][x], rhs[y][x])];
      }
      function updateVertex(x, y) {
        if (!(x === sx && y === sy)) {
          let minRhs = Infinity;
          let minFrom = null;
          for (const nb of getNeighborsWeighted(x, y, allowDiag)) {
            const nx = nb.x, ny = nb.y, cost = nb.cost;
            if (g[ny][nx] + cost < minRhs) {
              minRhs = g[ny][nx] + cost;
              minFrom = { x: nx, y: ny };
            }
          }
          rhs[y][x] = minRhs;
          cameFrom[y][x] = minFrom;
        }
        if (inOpen[y][x]) {
          for (let i = 0; i < open.length; i++) {
            if (open[i].x === x && open[i].y === y) {
              open.splice(i, 1);
              break;
            }
          }
          inOpen[y][x] = false;
        }
        if (g[y][x] !== rhs[y][x]) {
          open.push({ x, y, k: key(x, y) });
          inOpen[y][x] = true;
        }
      }
      function popMin() {
        let minIdx = 0;
        let minK = open[0].k;
        for (let i = 1; i < open.length; i++) {
          const k = open[i].k;
          if (k[0] < minK[0] || (k[0] === minK[0] && k[1] < minK[1])) {
            minK = k;
            minIdx = i;
          }
        }
        const node = open[minIdx];
        open.splice(minIdx, 1);
        inOpen[node.y][node.x] = false;
        return node;
      }
      updateVertex(gx, gy);
      while (open.length > 0 && (g[gy][gx] !== rhs[gy][gx] || open[0].k[0] < key(gx, gy)[0] || open[0].k[1] < key(gx, gy)[1])) {
        steps++;
        const u = popMin();
        lastClosed[u.y][u.x] = true;
        if (g[u.y][u.x] > rhs[u.y][u.x]) {
          g[u.y][u.x] = rhs[u.y][u.x];
          for (const nb of getNeighborsWeighted(u.x, u.y, allowDiag)) {
            updateVertex(nb.x, nb.y);
          }
        } else {
          g[u.y][u.x] = Infinity;
          updateVertex(u.x, u.y);
          for (const nb of getNeighborsWeighted(u.x, u.y, allowDiag)) {
            updateVertex(nb.x, nb.y);
          }
        }
      }
      // Reconstruct path from goal
      let path = [];
      let cur = { x: gx, y: gy };
      while (cur && !(cur.x === sx && cur.y === sy)) {
        path.push(cur);
        cur = cameFrom[cur.y][cur.x];
      }
      if (cur) path.push(cur);
      path.reverse();
      lastPath = path;
      lastOpen = inOpen.map(r => r.slice());
      lastClosed = inClosed.map(r => r.slice());
      return { found: g[gy][gx] < Infinity, path, steps, cost: g[gy][gx] };
    }
    });

    clearPathBtn.addEventListener("click", () => {
      lastPath = [];
      lastOpen = createBoolGrid(false);
      lastClosed = createBoolGrid(false);
      draw();
      setStatus("Cleared path and search visualization.");
    });

    diagCheckbox.addEventListener("change", () => {
      setStatus(`Diagonals ${diagCheckbox.checked ? "enabled" : "disabled"}.`);
    });

    // Initial state
    randomizeWalls(Number(densityInput.value));
    draw();
    setStatus("Draw or randomize walls, place Start/Goal, pick an algorithm, then press Run.");

  </script>
</body>
</html>